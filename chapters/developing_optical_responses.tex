\chapter{For Developers: Including New Optical Responses}

Optical responses are calculated in two steps:

\begin{enumerate}
\item the integrand,
\item and the integration over $k$.
\end{enumerate}

Both steps are implemented in FORTRAN code (thanks to Fred Nastos) and both are included with TINIBA. Including new optical subroutines only requires modifying the \emph{integrand}. For more information see \cite{sipe_second-order_2000}.

\section{Programs for Bulk and Layer-by-Layer response}
\label{sec:programs}

Do all the compilation in the \verb=master= node and in both 
\verb=SRC_1setinput=
and
\verb=SRC_2latam=.

There are two main steps in the calculation of the optical response:

\begin{enumerate}

\item the first one sets up the integrand and the
files are in\\
\verb=$TINIB/latm/SRC_1setinput=
\item the second one does the $\mathbf{k}$-integration and the files
  are in\\
\verb=$TINIBA/latm/SRC_2latam=
\end{enumerate}

\begin{itemize}
%%%%%%%%%%
\item\verb=$TINIBA/latm/SRC_1setinput=
%%%%%%%%%%

\begin{enumerate}
\item in
  \verb=integrands.f90=\\
 include a CASE and the name of the subroutine, i.e \\
\verb=   CASE(21)=\\
\verb=   CALL SHG1L=\\
then write the subroutine itself. You can follow the structure from
  any other subroutine that works, like SHG1L. 

\item in \verb=inparams.f90= do the following
\begin{itemize}
\item in the \verb=MODULE inparams= 
add the response prefactor as a parameter, i.e.\\
\verb=REAL(DP),PARAMETER::shg1_factor= $=\cdots$
\item in the \verb=MODULE inparams=  add the response prefactor in the array\\
\verb=spectrum_factor(number_of_known_spectrum_types)==\\       
$\vdots$\\
\verb=!    21           22          23           =\\
\verb=  shg1_factor, shg2_factor, leo_factor=,$\cdots$\\
$\vdots$\\
where it is {\bf very important} that the number chosen for the
\verb=CASE= of the response, i.e. 21, coincides with the position-entree in
the array.
\item in the \verb=SUBROUTINE readSpectrumFile= add the \verb=CASE=
 number in the appropriate response, where \verb=dims= is the rank
 and \verb=length= is the total number of
 Cartesian components of
the tensor's response, i.e.\\
$\vdots$
\begin{verbatim}
 CASE(21,42,44)
  WRITE(6,*) "Second-harmonic generation"
  dims = 3
  length = 27
\end{verbatim}
$\vdots$

since the rank is 3 and 3$^3$=27

\item in the \verb=SUBROUTINE deltaFactor= add the 
correct\\ \verb=deltaFunctionFactor==1 or 2\\ for 1-$\omega$ and 
2-$\omega$ transitions, respectively.
 The default value is\\
\verb=deltaFunctionFactor==1 for 1-$\omega$ response terms.
Otherwise include the response \verb=CASE= number, i.e.,\\
$\vdots$
\begin{verbatim}
 CASE(22,43,45)!shg 2-omega terms
   deltaFunctionFactor=2
 END SELECT
\end{verbatim}
$\vdots$

since \verb=shg2= is a 2-$\omega$ response term.
\end{itemize} 

\item in \verb=set_input_ascii.f90=
 the \verb='all'= the \verb='standard'= and the \\\verb='layer-by-layer'=
position and momentum matrix elements are set into arrays so they can be used by the 
\verb=intergands.f90= file. Most of the responses already have the required
matrix elements so this file should not be changed unless new matrix
elements are needed. Check that the momentum-matrix elements are
properly renormalized due to the scissors shift. 

\item in \verb=symmetry_operations.f90= include the \verb=CASE= number
  of the response in the appropriate transformation (linear,
  secon-order, etc.), i.e.\\
$\vdots$
\begin{verbatim}
  CASE(21,22,42,43,44,45)
   CALL transformationSecondOrderResponse(i_spectra)
\end{verbatim} 
$\vdots$

The symmetries are obtained from the file generated by the LDA program
and they obtain the following array
\begin{equation}\label{uno}
R_{ij\cdots}=\sum_{\mathrm{ab}\cdots}M_{i\mathrm{a}} M_{j\mathrm{b}}\cdots
,
\end{equation}
where the {\it italic} Cartesian subindices of $R_{ij\cdots}$ are chosen by the
tensor component to be calculated, \verb=-t= option, 
and the $\mathrm{roman}$
Cartesian subindices of the rotation matrices $M_{i\mathrm{a}}$ are
summed over.

The following four files basically do not need to be changed.
\item in \verb=arrays.f90= the arrays are allocated and de-allocated
  for things like the momentum matrix elements. So far it has all the
  arrays needed for many responses, so most likely there is no need to
  edit this file. The file also reads the LDA energies and scissored
  energies with the value of the provided scissor correction.
%Perhaps the layered spin injection response needs to add the
%appropriate array for the layered spin matrix elements.

\item \verb=constants.f90= has only constants and there is no need to
modify it.
\item \verb=file_control.f90= controls the flow of the calculation,
there is no need to
modify it.
\item \verb=functions.f90= calculates the standard and  layer-by-layer position
  matrix elements, the generalized derivatives of the position matrix
  elements, and other goodies not required. 
There is no apparent need to
modify it unless one wants to change the layer-by-layer response.

\item Compilation
\begin{itemize}
\item run \verb=compila_all.sh= to compile in the three plataforms
\item the executable is one directory down, i.e.\\
\verb=../set_input_32b= for the \verb=Xeon=\\
\verb=../set_input_64b= for the \verb=Itanium=\\
\verb=../set_input_quad= for the \verb=quad=
\item you may want to change the compiler and compilation flags in:\\
\verb=Makefile32b= for the \verb=Xeon=\\
\verb=Makefile64b= for the \verb=Itanium=\\
\verb=Makefilequad= for the \verb=quad=
\end{itemize}

\end{enumerate}

%%%%%%%%%%
\item\verb=$TINIBA/latm/SRC_2latam=
%%%%%%%%%%
\begin{enumerate}
\item\verb=inparams.f90= is the same as that of\\
\verb=$TINIBA/latm/SRC_1setinput=\\
it is linked so if you change it in \verb=SRC_1setinput=
 you must compile in \verb=SRC_2latam=!
\item \verb=tetra_method.f90=
\begin{itemize}
\item does the integration using the Tetrahedral Method.
\item you may want to play with the 
\verb=SUBROUTINE Which_Transitions= to chose particular transitions,
i.e. look in \verb=tetra_method_vc.f90=, but be sure that is
implemented for 2-$\omega$ terms.
\end{itemize}

\item \verb=constants.f90= has only constants and there is no need to
modify it.
\item \verb=globals.f90= global statements and there is no need to
modify it.
\item \verb=piksort.f90= there is no need to
modify it.
\item Compilation
\begin{itemize}
\item run \verb=compila_all.sh= to compile in the three plataforms
\item the executable is one directory down, i.e.\\
\verb=../tetra_method_32b= for the \verb=Xeon=\\
\verb=../tetra_method_64b= for the \verb=Itanium=\\
\verb=../tetra_method_quad= for the \verb=quad=
\item you may want to change the compiler and compilation flags in:\\
\verb=Makefile32b= for the \verb=Xeon=\\
\verb=Makefile64b= for the \verb=Itanium=\\
\verb=Makefilequad= for the \verb=quad=
\end{itemize}

\end{enumerate}

\item Name for the Response

The name of the response (i.e. \verb=rhomm=)
 must go in the following files complying with the particular context 
\begin{itemize}
\item in \verb=$TINIBA/utils=
\begin{enumerate}
\item \verb=all_responses.sh=
\item \verb=responses.sh=
\end{enumerate}
\item in \verb=$TINIBA/latm/SRC_1setinput=
\begin{enumerate}
\item \verb=arrays.f90=
\item \verb=inparams.f90=
\item \verb=set_input_ascii.f90=
\end{enumerate}
\item To include a new response once is coded as explained in
 Sec. \ref{sec:programs} 

\begin{itemize}
\item edit
\verb=$TINIBA/utils/responses.txt=  
and add the
 number and name of the respnse, perhaps you may want to modify\\
\verb=$TINIBA/utils/print_responses.pl=\\ for fine tunning
of the displayed text. 
\item\textcolor{red}{NOTE:}The names that appear in
  \verb=responses.txt= are the ones used, \verb=verbatim=, for the name
  of the calculated responses. Thus for a different name for the same
  response just modify this file!
\end{itemize}
\end{itemize}

%%%
\end{itemize}


\section{Shell for Bulk and Layer-by-Layer response}

\begin{itemize}

\item To run the optical responses execute and follow the instruction of the bash \verb=shell=:

  \verb=$TINIBA/utils/all_responses.sh=\\
which uses\\
\verb=$TINIBA/utils/responses_bms.sh=

\item To include a new response once is coded as explained in
 Sec. \ref{sec:programs} 

\begin{itemize}
\item edit
\verb=$TINIBA/utils/responses.txt=  
and add the
 number and name of the respnse, perhaps you may want to modify\\
\verb=$TINIBA/utils/print_responses.pl=\\ for fine tunning
of the displayed text.
\end{itemize}
\item The SHG is calculated with \verb=CASE==21 and does both 1-$\go$
  and 2-$\go$ terms.
\end{itemize}

% \section{a la Cabellos}

% This subsection only runs $\chi_{ij}(\omega)$ and $\chi_{ijk}(2\omega)$ for bulk semiconductors. It assumes that the experimental or GW band gap is known. We are planing to extend this version to other responses and the layer-by-layer analysis as well. $\chi_{ijk}(2\omega)$ is calculated in the length and velocity gauges with and without the appropriate scissor correction. See \cite{cabellos_effects_2009} for more information.

% \begin{itemize}
% \item go to:\\
% \verb= cd $HOME/$TINIBA/SRC_response/SRC_set=  
% \item Make a module. This has ``two'' names, one is the name of the
%   file itself,
% i.e. \verb=ishg1la.f90=
% and the other is the name of the module itself,
% i.e. \verb=IntegrandSHG1Mod.f90=,
%  that goes as the first
% line of the file.
% The file with the module has two functions with the
% response prefactor and a ``delta function factor'' depending if the
% response is 1-$\omega$ or 2-$\omega$. It also has the subroutine with
% the integrand that codifies the response to be calculated.\\
% Then you have to link the new module to these next subroutines/modules: 

% \item in \verb=IntegrandsMod.f90=
%    \begin{itemize}
%    \item at the top of the file insert the
%      name of the new module, i.e. \\ \verb=USE IntegrandSHG1Mod.f90, ONLY :: SHG1= 
%    \item Asign a case nomber, i.e.\\
%      \verb=case (21)=\\
%      \verb=CALL SGH1(i_spectra)=
%    \end{itemize}
% Notice that the case number is arbitrary but is is linked to the
% \verb=ONLY :: SHG1= 

% \item in \verb=SymmetryOperationsMod.f90=

% \begin{itemize}

% \item write the {\it case} number in the appropriate symmetry {\it transformation},
% i.e. \\
% \verb=  CASE(21,22,26,27,28,29,30,60,61,62,63,64,65,80,81)=\\
% \verb=  CALL transformationSecondOrderResponse(i_spectra)=
%      \end{itemize}
% since the example is for SHG which is a second order response given by a third rank tensor.

% \item in \verb=SpectrumParametersFileMod.f90=
%       \begin{itemize}
%       \item chose the tensor rank and its total number of Cartesian
%         components, i.e.\\
% \verb= CASE(21,22)= \\
% \verb=  WRITE(6,*) "Second-harmonic generation: Length Gauge"=\\
% \verb=  dims = = 3\\
% \verb=  length = = 27
%      \end{itemize}

% since the rank is 3 and 3$^3$=27

% \item in \verb=FileControlMod.f90= include

% \begin{itemize}
% \item \verb=USE IntegrandSHG1Mod, ONLY : SHG1_factor, SHG1DeltaFunctionFactor=
% \item
% \verb= CASE(21)=\\
% \verb= rtmp2 = =\verb= rtmp*SHG1_factor()=\\
% \verb= iTmp ==\verb= SHG1DeltaFunctionFactor()=
% \end{itemize}

% \end{itemize}        
% When you finish, you have to compile in the \verb=master=, then you can make use of the 
% advanced tool MakeMakefile.PL (no one uses it) :
% \begin{enumerate}
% \item \verb=./utils/=\textcolor{darkgreen}{MakeMakefile2010.PL}
% \item
%   \verb=./utils/=\textcolor{darkgreen}{compiler.sh}\\
% and follow instructions$\ldots$ the executable is in the previous directory.
% \end{enumerate}
%   % \begin{verbatim}
%   % Usage [Option]:
%   %   3264        : Compile 32 and 64 bits(xeon,itanium and quad)
%   %   xeon        : Compile 32  xeon
%   %   itanium     : Compile 64 itanium
%   %   quad        : Compile 64 quad
%   %   example: ./compiler.sh 3264
%   %   Stoping right now ...
%   % \end{verbatim}   

% After this a script has to driver this subrutine, there are several of them 
% if you want to use one of this:\\
% You have to include the number of response in those scripts\\
% /home/\$USER/\$TINIBA/SRC$_{-}$response/\textcolor{darkgreen}{responseSHG.sh}\\
% In this script include a line like this
% \begin{verbatim}
% NAMERES[1]=chi1  ;SIZERES[1]="2"
% \end{verbatim}
% As you see one of this is the name of the subroutine and other is the lenght of the tensor\\ 
% \verb=$HOME/$TINIBA/SRC_response/menu.sh=
% In this script include a line like this
% \begin{verbatim}
% printf "\t${GREEN}22${NC} ${BLU}${NAMERES[22]}${NC}  
% (${GREEN}Length 2 omega${NC})\n"
% \end{verbatim}

% In order to be able to run, try it with small case. 
% if you are not able to run ask to Bernardo en the coffe 
% break in order to solve the problem. 
